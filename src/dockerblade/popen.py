# -*- coding: utf-8 -*-
__all__ = ('Popen',)

from typing import Optional, Iterator, Dict, Any
import time

from docker.models.containers import Container as DockerContainer
import attr
import docker

from .stopwatch import Stopwatch
from .exceptions import TimeoutExpired


class Popen:
    """Provides access to a process that is running inside a given shell.
    Inspired by the :class:`subprocess.Popen` interface within the Python
    standard library. Unlike :class:`subprocess.Popen`, instances of this
    class should be generated by :meth:`ShellProxy.popen` rather than via
    the constructor.

    Attributes
    ----------
    stream: Iterator[str]
        An output stream for this process.
    args: str
        The argument string that was used to generate this process.
    pid: int, optional
        The PID of this process, if known.
    finished: bool
        A dynamic flag (i.e., a property) that indicates whether this process
        has terminated.
    retcode: int, optional
        The return code produced by this process, if known.
    """
    def __init__(self,
                 args: str,
                 uid: str,
                 shell: 'Shell',
                 container: DockerContainer,
                 docker_api: docker.APIClient,
                 exec_id: int,
                 stream: Iterator[bytes]
                 ) -> None:
        self.__args = args
        self.__uid = uid
        self.__container = container
        self.__shell = shell
        self.__docker_api = docker_api
        self.__exec_id = exec_id
        self.__stream = stream
        self.__pid: Optional[int] = None
        self.__returncode: Optional[int] = None

    def _inspect(self) -> Dict[str, Any]:
        return self.__docker_api.exec_inspect(self.__exec_id)

    @property
    def stream(self) -> Iterator[str]:
        for line_bytes in self.__stream:
            yield line_bytes.decode('utf-8')

    @property
    def args(self) -> str:
        return self.__args

    def __uid_to_pid(self) -> Optional[int]:
        prefix = f'/bin/bash -c echo {self.__uid} > /dev/null && '
        cmd = f'ps -eo pid,cmd | grep "{prefix}"'
        while not self.finished:
            code, output, duration = self.__shell.execute(cmd)
            for line in output.split('\n'):
                pid_str, _, p_cmd = line.strip().partition(' ')
                if p_cmd.startswith(prefix):
                    return int(pid_str)
        return None

    @property
    def pid(self) -> Optional[int]:
        if not self.__pid and not self.finished:
            self.__pid = self.__uid_to_pid()
        return self.__pid

    @property
    def finished(self) -> bool:
        return self.returncode is not None

    @property
    def returncode(self) -> Optional[int]:
        if self.__returncode is None:
            self.__returncode = self._inspect()['ExitCode']
        return self.__returncode

    def send_signal(self, sig: int) -> None:
        """Sends a given signal to the process.

        Parameters
        ----------
        sig: int
            The signal number.
        """
        pid = self.pid
        if pid:
            self.__shell.send_signal(pid, sig)

    def kill(self) -> None:
        """Kills the process via a SIGKILL signal."""
        self.send_signal(signal.SIGKILL)

    def terminate(self) -> None:
        """Terminates the process via a SIGTERM signal."""
        self.send_signal(signal.SIGTERM)

    def poll(self) -> Optional[int]:
        """Checks if the process has terminated and returns its returncode."""
        return self.returncode

    def wait(self, time_limit: Optional[float] = None) -> int:
        """Blocks until the process has terminated.

        Parameters
        ----------
        time_limit: float, optional
            An optional time limit.
        Raises
        ------
        TimeoutExpired:
            if the process does not terminate within the specified timeout.
        """
        stopwatch = Stopwatch()
        stopwatch.start()
        while not self.finished:
            if time_limit and stopwatch.duration > time_limit:
                raise TimeoutExpired(self.args, time_limit)
            time.sleep(0.05)
        assert self.returncode is not None
        return self.returncode
