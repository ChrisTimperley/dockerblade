from __future__ import annotations

__all__ = ("Popen",)

import signal
import time
import typing as t
from pathlib import Path
from typing import Any

import attr
from loguru import logger

from .exceptions import TimeoutExpired
from .stopwatch import Stopwatch

if t.TYPE_CHECKING:
    from collections.abc import Iterator

    from docker import APIClient as DockerAPIClient

    from .container import Container



def host_pid_to_container_pid(pid_host: int) -> int | None:
    fn_proc = Path(f"/proc/{pid_host}/status")
    with fn_proc.open() as fh:
        for line in fh:
            if line.startswith("NSpid:"):
                return int(line.split()[2])
    return None


@attr.s(slots=True, eq=False, hash=False)
class Popen:
    """Provides access to a process that is running inside a given shell.

    Inspired by the :class:`subprocess.Popen` interface within the Python
    standard library. Unlike :class:`subprocess.Popen`, instances of this
    class should be generated by :meth:`ShellProxy.popen` rather than via
    the constructor.

    Attributes
    ----------
    stream: Union[Iterator[str], Iterator[bytes]]
        An output stream for this process.
    args: str
        The argument string that was used to generate this process.
    cwd: str
        The absolute path of the directory in the container where this
        command should be executed.
    pid: int, optional
        The PID of this process, if known.
    finished: bool
        A dynamic flag (i.e., a property) that indicates whether this process
        has terminated.
    retcode: int, optional
        The return code produced by this process, if known.
    encoding: str, optional
        The encoding, if any, used by this process. If :code:`None`, the
        output stream of this process will be treated as a bytestream.
    """
    args: str = attr.ib()
    cwd: str = attr.ib()
    _container: Container = attr.ib()
    _docker_api: DockerAPIClient = attr.ib(repr=False)
    _exec_id: int = attr.ib()
    _stream: Iterator[bytes] = attr.ib(repr=False)
    _pid: int | None = attr.ib(init=False, default=None, repr=False)
    _pid_host: int | None = attr.ib(init=False, default=None)
    _returncode: int | None = attr.ib(init=False, default=None)
    encoding: str | None = attr.ib(default="utf-8")

    def _inspect(self) -> dict[str, Any]:
        info: dict[str, Any] = self._docker_api.exec_inspect(self._exec_id)
        assert isinstance(info, dict)
        return info

    @property
    def stream(self) -> Iterator[bytes] | Iterator[str]:
        def decoded_stream() -> Iterator[str]:
            assert self.encoding
            for line_bytes in self._stream:
                yield line_bytes.decode(self.encoding)

        if self.encoding is None:
            yield from self._stream
        else:
            yield from decoded_stream()

    @property
    def host_pid(self) -> int | None:
        if not self._pid_host:
            self._pid_host = self._inspect()["Pid"]
        return self._pid_host

    @property
    def pid(self) -> int | None:
        host_pid = self.host_pid
        if not self._pid and host_pid:
            self._pid = host_pid_to_container_pid(host_pid)
        return self._pid

    @property
    def finished(self) -> bool:
        return self.returncode is not None

    @property
    def returncode(self) -> int | None:
        if self._returncode is None:
            self._returncode = self._inspect()["ExitCode"]
        return self._returncode

    def send_signal(self, sig: int) -> None:
        """Sends a given signal to the process.

        Parameters
        ----------
        sig: int
            The signal number.
        """
        pid = self.pid
        docker_container = self._container._docker
        logger.debug(f"sending signal {sig} to process {pid}")
        cmd = f"kill -{sig} -{pid}"
        if pid:
            docker_container.exec_run(cmd,
                                      stdout=False, stderr=False, user="root")

    def kill(self) -> None:
        """Kills the process via a SIGKILL signal."""
        self.send_signal(signal.SIGKILL)

    def terminate(self) -> None:
        """Terminates the process via a SIGTERM signal."""
        self.send_signal(signal.SIGTERM)

    def poll(self) -> int | None:
        """Checks if the process has terminated and returns its returncode."""
        return self.returncode

    def wait(self, time_limit: float | None = None) -> int:
        """Blocks until the process has terminated.

        Parameters
        ----------
        time_limit: float, optional
            An optional time limit.

        Raises
        ------
        TimeoutExpired:
            if the process does not terminate within the specified timeout.
        """
        stopwatch = Stopwatch()
        stopwatch.start()
        while not self.finished:
            if time_limit and stopwatch.duration > time_limit:
                logger.debug("timeout")
                raise TimeoutExpired(self.args, time_limit)
            time.sleep(0.05)
        assert self.returncode is not None
        return self.returncode
